-- MySQL Script generated by MySQL Workbench
-- 02/11/15 17:31:49
-- Model: New Model    Version: 1.0
-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='TRADITIONAL,ALLOW_INVALID_DATES';

-- -----------------------------------------------------
-- Schema hollyhotel
-- -----------------------------------------------------
DROP SCHEMA IF EXISTS `hollyhotel` ;

-- -----------------------------------------------------
-- Schema hollyhotel
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `hollyhotel` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci ;
USE `hollyhotel` ;

-- -----------------------------------------------------
-- Table `CUSTOMER`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CUSTOMER` ;

CREATE TABLE IF NOT EXISTS `hollyhotel`.`CUSTOMER` (
  `CustomerID` INT NOT NULL AUTO_INCREMENT COMMENT 'Surrogate Key',
  `CustomerType` VARCHAR(1) NOT NULL DEFAULT 'C' COMMENT '(C)ustomer or (O)rganization\n--Possibly convert this over to Name_Type?',
  `FirstName` VARCHAR(30) NOT NULL COMMENT 'Required when this is a Customer  Record',
  `LastName` VARCHAR(30) NOT NULL COMMENT 'Required for a Customer Record',
  `OrganizationName` VARCHAR(45) NOT NULL COMMENT 'Required when the type is organization',
  `ContactInfoConfidential` TINYINT(1) NULL DEFAULT 0 COMMENT 'Column used to note if the Customers want to keep their information confidential from outside parties',
  `Primary_Organization_Contact` INT NULL COMMENT 'If the \"Customer\" is an organization, then require a contact (points to another Customer Record)',
  PRIMARY KEY (`CustomerID`),
  INDEX `Organization_PrimaryContactID_idx` (`Primary_Organization_Contact` ASC),
  UNIQUE INDEX `CUSTOMER_AK1` (`FirstName` ASC, `LastName` ASC, `OrganizationName` ASC),
  CONSTRAINT `Organization_PrimaryContactID_FK`
    FOREIGN KEY (`Primary_Organization_Contact`)
    REFERENCES `hollyhotel`.`CUSTOMER` (`CustomerID`)
    ON DELETE RESTRICT
    ON UPDATE RESTRICT)
ENGINE = InnoDB
COMMENT = 'Table contains the primary information for a customer or org' /* comment truncated */ /*anization*/;

#customerCREATE INDEX `Organization_PrimaryContactID_idx` ON `CUSTOMER` (`Primary_Organization_Contact` ASC);



-- -----------------------------------------------------
-- Table `PHONE`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `PHONE` ;

CREATE TABLE IF NOT EXISTS `PHONE` (
  `CustomerID` INT NOT NULL COMMENT 'Foreign key, pointing to the master customer record',
  `PhoneNumSeq` INT NOT NULL DEFAULT 0 COMMENT '0 = Main, 1 = Office, 2 = Cell? -- (Possibly move this over to the Type_Name table)',
  `PhoneNum` VARCHAR(10) NULL COMMENT 'Actual Phone number, removing the dashes.  number must be between 1001000000-9999999999',
  PRIMARY KEY (`CustomerID`, `PhoneNumSeq`),
  CONSTRAINT `PHONE_CUSTOMERID_FK`
    FOREIGN KEY (`CustomerID`)
    REFERENCES `CUSTOMER` (`CustomerID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Contains the multiple phone numbers that a customer may have';

CREATE INDEX `PHONE_CUSTOMERID_FK_idx` ON `PHONE` (`CustomerID` ASC);


-- -----------------------------------------------------
-- Table `ADDRESS`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `ADDRESS` ;

CREATE TABLE IF NOT EXISTS `ADDRESS` (
  `CustomerID` INT NOT NULL COMMENT 'Foreign key, pointing to the master customer record',
  `AddressSeq` INT NOT NULL DEFAULT 0 COMMENT '0 = Bill-to, 1 = Alternate?  - - (Possibly move this over to the Type_Name table)',
  `Address1` VARCHAR(45) NULL COMMENT 'Street Address Line 1',
  `Address2` VARCHAR(45) NULL COMMENT 'Street Address Line 2',
  `Address3` VARCHAR(45) NULL COMMENT 'Street Address Line 3',
  `Address4` VARCHAR(45) NULL COMMENT 'Street Address Line 4',
  `City` VARCHAR(45) NULL,
  `State` VARCHAR(3) NULL COMMENT 'State Abbreviation',
  `Zip` VARCHAR(10) NULL,
  `Country` VARCHAR(45) NULL,
  PRIMARY KEY (`CustomerID`, `AddressSeq`),
  CONSTRAINT `PHONE_CUSTOMERID_FK0`
    FOREIGN KEY (`CustomerID`)
    REFERENCES `CUSTOMER` (`CustomerID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Contains the multiple addresses that a customer may have';

CREATE INDEX `PHONE_CUSTOMERID_FK_idx` ON `ADDRESS` (`CustomerID` ASC);


-- -----------------------------------------------------
-- Table `EVENT`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `EVENT` ;

CREATE TABLE IF NOT EXISTS `EVENT` (
  `EventID` INT NOT NULL AUTO_INCREMENT COMMENT 'Surrogate Key used to uniquely identify an event',
  `EventName` VARCHAR(45) NOT NULL COMMENT 'Name of the event (Bob and Jill\'s Wedding)',
  `HostID` INT NOT NULL COMMENT 'Field to hold the primary contact for the event',
  `StartDate` DATETIME NOT NULL COMMENT 'When the event is supposed to take place (used in calculating room reservations for blocks of rooms)',
  `EndDate` DATETIME NOT NULL COMMENT 'When the event concludes (used in calculating room reservations for blocks of rooms)',
  `RoomsReserved` INT(11) NOT NULL DEFAULT 0 COMMENT 'Holds the number rooms that are held for guests associated with this event to convert into actual reservations.  This number will  be decremented as Guests for this event create reservations',
  `RoomsReservedUntil` DATETIME NOT NULL COMMENT 'This field is used to tell the reservation system how long to keep the Rooms Reserved before allowing other guests to make reservations.  Possibly use a trigger to default this to two weeks prior to StartDate',
  PRIMARY KEY (`EventID`),
  CONSTRAINT `EVENT_HostID_FK`
    FOREIGN KEY (`HostID`)
    REFERENCES `CUSTOMER` (`CustomerID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB
COMMENT = 'This Table contains the information for an event such as a W' /* comment truncated */ /*edding, corportate meeting, etc
An event requires at least one primary reservation of a room (meeting or sleeping)*/;

CREATE INDEX `fk_EVENT_CUSTOMER1_idx` ON `EVENT` (`HostID` ASC);


-- -----------------------------------------------------
-- Table `TYPE_NAME`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `TYPE_NAME` ;

CREATE TABLE IF NOT EXISTS `TYPE_NAME` (
  `TypeNameID` INT NOT NULL AUTO_INCREMENT COMMENT 'Auto assigned surrogate key',
  `UsageID` VARCHAR(20) NOT NULL COMMENT 'Used to filter the categories by their usage.  i.e. BuildingID, WingID, BedType',
  `Name` VARCHAR(45) NOT NULL COMMENT 'Descriptive field of the different types (King Bed, Queen, etc.)',
  `UsageRank` INT NULL DEFAULT 0 COMMENT 'Used for sorting, or ranking for subsitution (King bed is better than a Queen Bed)',
  PRIMARY KEY (`TypeNameID`, `UsageID`))
ENGINE = InnoDB
COMMENT = 'This is a lookup table holds all of the Categories that can ' /* comment truncated */ /*be assigned, along with the names that are used for the Buildings/ Wings, etc*/;


-- -----------------------------------------------------
-- Table `BUILDING_WING`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `BUILDING_WING` ;

CREATE TABLE IF NOT EXISTS `BUILDING_WING` (
  `BuildingID` INT NOT NULL COMMENT 'Building ID, Foreign Key that is maintained in Type_Name with a Usage of BuildingID',
  `WingID` INT NOT NULL COMMENT 'Wing ID, Foreign Key that is maintained in Type_Name with a UsageID of WingID',
  `NumberOfFloors` INT NOT NULL DEFAULT 1 COMMENT 'Number of Floors that the wing has.  Must be one or more',
  PRIMARY KEY (`BuildingID`, `WingID`),
  CONSTRAINT `BUILDING_WING_BuildingID_FK`
    FOREIGN KEY (`BuildingID`)
    REFERENCES `TYPE_NAME` (`TypeNameID`)
    ON DELETE RESTRICT
    ON UPDATE RESTRICT,
  CONSTRAINT `BUILDING_WING_WingID_FK`
    FOREIGN KEY (`WingID`)
    REFERENCES `TYPE_NAME` (`TypeNameID`)
    ON DELETE RESTRICT
    ON UPDATE RESTRICT)
ENGINE = InnoDB
COMMENT = 'Assigns Wings to Buildings, as Wings can be used in multiple' /* comment truncated */ /* buildings (West, East, etc.)*/;

CREATE INDEX `fk_BUILDING_WING_TYPE_NAME1_idx` ON `BUILDING_WING` (`WingID` ASC);


-- -----------------------------------------------------
-- Table `WING_FLOOR`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `WING_FLOOR` ;

CREATE TABLE IF NOT EXISTS `WING_FLOOR` (
  `BuildingID` INT NOT NULL COMMENT 'Foreign Key pointing to Building_WING',
  `WingID` INT NOT NULL COMMENT 'Foreign Key pointing to Building_WING',
  `FloorNumber` INT NOT NULL COMMENT '>=1 and <= BUILDING_WING.NumberOfFloors',
  `SmokingProhibited` TINYINT(1) NULL DEFAULT 0 COMMENT 'Marks all rooms on this Floor/Wing/Building combination on Non-smoking',
  PRIMARY KEY (`WingID`, `FloorNumber`, `BuildingID`),
  CONSTRAINT `WING_FLOOR_Building_FK`
    FOREIGN KEY (`BuildingID` , `WingID`)
    REFERENCES `BUILDING_WING` (`BuildingID` , `WingID`)
    ON DELETE RESTRICT
    ON UPDATE RESTRICT)
ENGINE = InnoDB
COMMENT = 'This table Maintains information that is specific to a floor' /* comment truncated */ /* that exists in a building/wing.  Rooms are then assigned to this Building/Wing/Floor combination*/;

CREATE INDEX `WING_FLOOR_Building_FK_idx` ON `WING_FLOOR` (`BuildingID` ASC, `WingID` ASC);

-- -----------------------------------------------------
-- Table `ROOM`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `ROOM` ;

CREATE TABLE IF NOT EXISTS `ROOM` (
  `RoomID` INT NOT NULL AUTO_INCREMENT COMMENT 'Surrogate key that uniquely defines the room',
  `RoomNumber` INT NOT NULL COMMENT 'Room Number for the specific Building/Wing/Floor - This is the friendly number shown to users/guests',
  `Floor` INT NOT NULL COMMENT 'Floor that the room belongs to',
  `WingID` INT NOT NULL COMMENT 'Wing that the room belongs to',
  `BuildingID` INT NOT NULL COMMENT 'Building that the room belongs to',
  `ParentRoomID` INT NULL COMMENT 'Used when Multiple rooms can be combined into a single room/reservation',
  PRIMARY KEY (`RoomID`),
  CONSTRAINT `ROOM_ParentRoomID_FK`
    FOREIGN KEY (`ParentRoomID`)
    REFERENCES `ROOM` (`RoomID`)
    ON DELETE RESTRICT
    ON UPDATE RESTRICT,
  CONSTRAINT `ROOM_WING_FLOOR_FK`
    FOREIGN KEY (`WingID`, `Floor`, `BuildingID`)
    REFERENCES WING_FLOOR(`WingID`, `FloorNumber`, `BuildingID`)
    ON DELETE RESTRICT
    ON UPDATE RESTRICT
    )
ENGINE = InnoDB
COMMENT = 'Table that maintains all of the possible rooms.  ';

CREATE INDEX `fk_ROOM_ROOM1_idx` ON `ROOM` (`ParentRoomID` ASC);

CREATE UNIQUE INDEX `ROOM_ak1` ON `ROOM` (`RoomNumber` ASC, `Floor` ASC, `WingID` ASC, `BuildingID` ASC);

CREATE INDEX `ROOM_WING_FLOOR_FK_idx` ON `ROOM` (`Floor` ASC, `WingID` ASC, `BuildingID` ASC);


-- -----------------------------------------------------
-- Table `RESERVATION`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `RESERVATION` ;

CREATE TABLE IF NOT EXISTS `RESERVATION` (
  `ReservationID` INT NOT NULL AUTO_INCREMENT COMMENT 'Surrogate Key to uniquely identify the reservation',
  `ParentResID` INT NULL COMMENT 'Allows the creation of a primary reservation that then can have multiple reservations assigned ',
  `BillToID` INT NOT NULL COMMENT 'The customer that will be responsible for paying for the room',
  `GuestID` INT NULL COMMENT 'The customer that will be checking in and using the room\nIf this field is null, then use BillToID; this is only specified when the another \"customer\" is responible for paying for the room charges',
  `EventID` INT NULL COMMENT 'Used to validate group/event reservations',
  `RoomType` INT NOT NULL COMMENT 'Uses lookup table Type_Name with a UsageID of RoomType',
  `StartDate` DATETIME NOT NULL COMMENT 'Check-In Date',
  `EndDate` DATETIME NOT NULL COMMENT 'Check-out Date',
  `Rate` DECIMAL(12,2) NULL DEFAULT 0 COMMENT 'Room Rate that will be charged for the reservation ',
  `Deposit` DECIMAL(12,2) NULL COMMENT 'For Customers required to pre-pay',
  `RoomID` INT NULL COMMENT 'Used when a specific room is booked; Neccessary for booking Meeting Rooms',
  `Smoking` INT NULL COMMENT '0 = No, 1 = Yes, 2 = No Preference',
  `ConvertedToStay` TINYINT(1) NULL DEFAULT 0 COMMENT 'Marks when a reservation is converted to a stay, so that the scheduling system can ignore it',
  PRIMARY KEY (`ReservationID`),
  CONSTRAINT `RESERVATION_BillToID_FK`
    FOREIGN KEY (`BillToID`)
    REFERENCES `CUSTOMER` (`CustomerID`)
    ON DELETE RESTRICT
    ON UPDATE RESTRICT,
  CONSTRAINT `RESERVATION_GuestID_FK`
    FOREIGN KEY (`GuestID`)
    REFERENCES `CUSTOMER` (`CustomerID`)
    ON DELETE RESTRICT
    ON UPDATE RESTRICT,
  CONSTRAINT `RESERVATION_EventID_FK`
    FOREIGN KEY (`EventID`)
    REFERENCES `EVENT` (`EventID`)
    ON DELETE NO ACTION
    ON UPDATE CASCADE,
  CONSTRAINT `RESERVATION_RoomID`
    FOREIGN KEY (`RoomID`)
    REFERENCES `ROOM` (`RoomID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB
COMMENT = 'Table that stores the information neccessary to make a room ' /* comment truncated */ /*reservation*/;

CREATE INDEX `fk_RESERVATION_CUSTOMER1_idx` ON `RESERVATION` (`BillToID` ASC);

CREATE INDEX `fk_RESERVATION_CUSTOMER1_idx1` ON `RESERVATION` (`GuestID` ASC);

CREATE INDEX `fk_RESERVATION_EVENT1_idx` ON `RESERVATION` (`EventID` ASC);

CREATE INDEX `fk_RESERVATION_ROOM1_idx` ON `RESERVATION` (`RoomID` ASC);


-- -----------------------------------------------------
-- Table `ROOM_BEDS`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `ROOM_BEDS` ;

CREATE TABLE IF NOT EXISTS `ROOM_BEDS` (
  `RoomID` INT NOT NULL,
  `BedSequence` INT NOT NULL,
  `BedType` INT NOT NULL,
  PRIMARY KEY (`RoomID`, `BedSequence`),
  CONSTRAINT `BEDS_RoomID_FK`
    FOREIGN KEY (`RoomID`)
    REFERENCES `ROOM` (`RoomID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `BEDS_TYPE_BedType_FK`
    FOREIGN KEY (`BedType`)
    REFERENCES `TYPE_NAME` (`TypeNameID`)
    ON DELETE NO ACTION
    ON UPDATE RESTRICT)
ENGINE = InnoDB
COMMENT = 'Detail child table of rooms that specifies the types of beds' /* comment truncated */ /* that are (or in the case of meeting rooms, can be) part of the room's configuration*/;

CREATE INDEX `fk_BEDS_TYPE_NAME1_idx` ON `ROOM_BEDS` (`BedType` ASC);


-- -----------------------------------------------------
-- Table `ROOM_DETAIL`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `ROOM_DETAIL` ;

CREATE TABLE IF NOT EXISTS `ROOM_DETAIL` (
  `RoomID` INT NOT NULL COMMENT 'Points to the Room record',
  `RoomType` INT NOT NULL COMMENT 'Type of room, such as Sleeping, Meeting, etc.  Foreign Key)',
  `Capacity` INT NOT NULL DEFAULT 0 COMMENT 'Meeting Room this is Seating Capacity\nSleeping Room this is Sleeping Capacity',
  `Toliet` TINYINT(1) NULL COMMENT 'Only required if the Room Type is Meeting',
  `PermitSmoking` TINYINT(1) NULL DEFAULT 0 COMMENT 'Used if a specific room permits smoking; this will be used in conjunction with the floor setting. This is only required for sleeping rooms',
  `ExtraSpace` INT NULL COMMENT 'Sleeping Room Specific setting,',
  `Rate` DECIMAL(12,2) NOT NULL DEFAULT 0 COMMENT 'Suites/Sleeping this is the daily rate\nMeeting Rooms this is the Hourly Rate',
  PRIMARY KEY (`RoomID`, `RoomType`),
  INDEX `ROOM_DETAIL_RoomType_FK_idx` (`RoomType` ASC),
  CONSTRAINT `ROOM_DETAIL_RoomID_FK`
    FOREIGN KEY (`RoomID`)
    REFERENCES `hollyhotel`.`ROOM` (`RoomID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `ROOM_DETAIL_RoomType_FK`
    FOREIGN KEY (`RoomType`)
    REFERENCES `hollyhotel`.`TYPE_NAME` (`TypeNameID`)
    ON DELETE RESTRICT
    ON UPDATE RESTRICT)
ENGINE = InnoDB
COMMENT = 'Contains the specific information based on the type of prope' /* comment truncated */ /*rties that a room will have depending on the room type.  Room Requires at least one assignment (business logic)*/;


#CREATE INDEX `ROOM_DETAIL_RoomType_FK_idx` ON `ROOM_DETAIL` (`RoomType` ASC);


-- -----------------------------------------------------
-- Table `ROOM_ADJ`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `ROOM_ADJ` ;

CREATE TABLE IF NOT EXISTS `ROOM_ADJ` (
  `RoomID` INT NOT NULL COMMENT 'Primary Room ID',
  `AdjacentRoomID` INT NOT NULL COMMENT 'Adjacent Room ID',
  PRIMARY KEY (`RoomID`, `AdjacentRoomID`),
  CONSTRAINT `ROOM_ADJ_RoomID_FK`
    FOREIGN KEY (`RoomID`)
    REFERENCES `ROOM` (`RoomID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `ROOM_ADJ_AdjacentRoomID_FK`
    FOREIGN KEY (`AdjacentRoomID`)
    REFERENCES `ROOM` (`RoomID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'This table is used to define when a room is adjacent to anot' /* comment truncated */ /*her room.  In the case of sleeping rooms, there should only be one adjacancy, while in meeting, there can be multiple (business logic)*/;

#CREATE INDEX `fk_ROOM_ADJ_ROOM1_idx` ON `ROOM_ADJ` (`AdjacentRoomID` ASC);


-- -----------------------------------------------------
-- Table `RESERVATION_MEALS`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `RESERVATION_MEALS` ;

CREATE TABLE IF NOT EXISTS `RESERVATION_MEALS` (
  `ReservationID` INT NOT NULL COMMENT 'Foreign Key to the Reservation',
  `Date` DATETIME NOT NULL COMMENT 'Date/Time of the requested meal',
  `MealID` INT NOT NULL COMMENT 'Meal Type (as souced in Type_Name); i.e. BreakFast, Lunch',
  `ServiceFor` INT NULL COMMENT 'Number of Guests that the meal will need to serve',
  PRIMARY KEY (`ReservationID`, `Date`, `MealID`),
  CONSTRAINT `RESERVATION_MEALS_RESERVATIONID_FK`
    FOREIGN KEY (`ReservationID`)
    REFERENCES `RESERVATION` (`ReservationID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `RESERVATION_MEALS_MealID_FK`
    FOREIGN KEY (`MealID`)
    REFERENCES `TYPE_NAME` (`TypeNameID`)
    ON DELETE NO ACTION
    ON UPDATE RESTRICT)
ENGINE = InnoDB
COMMENT = 'Associates Meals reserved for events with a reservation, and' /* comment truncated */ /* provides the neccessary detail.  Details about the meals to be served are not being stored inside this system.*/;

CREATE INDEX `fk_RESERVATION_MEALS_TYPE_NAME1_idx` ON `RESERVATION_MEALS` (`MealID` ASC);


-- -----------------------------------------------------
-- Table `RES_FEATURES`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `RES_FEATURES` ;

CREATE TABLE IF NOT EXISTS `RES_FEATURES` (
  `ReservationID` INT NOT NULL COMMENT 'Correlates this record to the parent reservation record',
  `FeatureSequence` INT NOT NULL COMMENT 'This field allows assignment of multiple features and beds to the reservation',
  `BedFeatureID` INT NOT NULL COMMENT 'This field defines the customers requirements for features or beds, which will use a filtered view of the TYPE_NAME lookup table',
  `ProximityID` INT NULL COMMENT 'Specifies the maximum proximity to feature the customer would prefer.  Used only in features (not for Beds)',
  PRIMARY KEY (`ReservationID`, `FeatureSequence`),
  CONSTRAINT `RES_FEATURES_ReservationID_FK`
    FOREIGN KEY (`ReservationID`)
    REFERENCES `RESERVATION` (`ReservationID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `RES_FEATURES_BedFeatureID_FK`
    FOREIGN KEY (`BedFeatureID`)
    REFERENCES `TYPE_NAME` (`TypeNameID`)
    ON DELETE NO ACTION
    ON UPDATE RESTRICT,
  CONSTRAINT `RES_FEATURES_ProximityID`
    FOREIGN KEY (`ProximityID`)
    REFERENCES `TYPE_NAME` (`TypeNameID`)
    ON DELETE NO ACTION
    ON UPDATE RESTRICT)
ENGINE = InnoDB
COMMENT = 'This table holds all of the requirements that a customer has' /* comment truncated */ /* for a room.  This can include up to two beds, proximity to pools, loading dock, parking lot, etc.*/;

CREATE INDEX `fk_RES_BEDS_TYPE_NAME1_idx` ON `RES_FEATURES` (`BedFeatureID` ASC);

CREATE INDEX `RES_FEATURES_ProximityID_idx` ON `RES_FEATURES` (`ProximityID` ASC);


-- -----------------------------------------------------
-- Table `STAY`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `STAY` ;

CREATE TABLE IF NOT EXISTS `STAY` (
  `StayID` INT NOT NULL AUTO_INCREMENT COMMENT 'Surrogate Key; ',
  `BillToID` INT NOT NULL COMMENT 'The customer that will receive the room charges (Not Null)',
  `GuestID` INT NULL COMMENT 'Assigned to the occupant of the room, if it is different than the person who is responsible for paying for the room charges.',
  `ReservationID` INT NULL COMMENT 'Informational field that points back to the reservation that this record originated from.  Not required',
  `EventID` INT NULL COMMENT 'If the stay is part of an event, this value can be assigned.  Added to this table to find the responsible party',
  `RoomID` INT NOT NULL COMMENT 'Links the room to the reservation',
  `RoomType` INT NOT NULL COMMENT 'Specifies how the room is utilized',
  `CheckIn` DATETIME NOT NULL COMMENT 'Time that that stay begins',
  `CheckOut` DATETIME NULL COMMENT 'Actual Checkout time',
  `AnticipatedCheckOut` DATETIME NULL COMMENT 'This column is used to all the scheduler to figure out when a room will be available again when it is currently being occupied.  When converted over from a Reservation, this is the CheckOut date',
  PRIMARY KEY (`StayID`),
  CONSTRAINT `STAY_BillToID_FK`
    FOREIGN KEY (`BillToID`)
    REFERENCES `CUSTOMER` (`CustomerID`)
    ON DELETE RESTRICT
    ON UPDATE NO ACTION,
  CONSTRAINT `STAY_GuestID_FK`
    FOREIGN KEY (`GuestID`)
    REFERENCES `CUSTOMER` (`CustomerID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `STAY_ReservationID_FK`
    FOREIGN KEY (`ReservationID`)
    REFERENCES `RESERVATION` (`ReservationID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `STAY_EventID_FK`
    FOREIGN KEY (`EventID`)
    REFERENCES `EVENT` (`EventID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `STAY_RoomID_FK`
    FOREIGN KEY (`RoomID`)
    REFERENCES `ROOM` (`RoomID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
CONSTRAINT `STAY_RoomType_FK`
    FOREIGN KEY (`RoomType`)
    REFERENCES `TYPE_NAME` (`TypeNameID`)
    ON DELETE RESTRICT
    ON UPDATE RESTRICT)
ENGINE = InnoDB
COMMENT = 'This table is used to store the details of the Stay.  A reco' /* comment truncated */ /*rd is created for each room that is checked out to a Guest.  Records can be created from a reservation, though they do not need to be*/;

#CREATE INDEX `fk_STAY_CUSTOMER1_idx` ON `STAY` (`BillToID` ASC);

#CREATE INDEX `fk_STAY_CUSTOMER1_idx1` ON `STAY` (`GuestID` ASC);

#CREATE INDEX `fk_STAY_RESERVATION1_idx` ON `STAY` (`ReservationID` ASC);

#CREATE INDEX `fk_STAY_EVENT1_idx` ON `STAY` (`EventID` ASC);

#CREATE INDEX `fk_STAY_ROOM1_idx` ON `STAY` (`RoomID` ASC);


-- -----------------------------------------------------
-- Table `STAY_CHARGES`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `STAY_CHARGES` ;

CREATE TABLE IF NOT EXISTS `STAY_CHARGES` (
  `ChargeNum` INT NOT NULL AUTO_INCREMENT COMMENT 'Surrogate Key',
  `StayID` INT NOT NULL COMMENT 'Foreign Key, pointing to Stay',
  `ChargeTo` INT NOT NULL DEFAULT 0 COMMENT 'Specifies if this is a room charge or another service;  room charge  goes to the BillToID, all others go to the Guest',
  `ChargeType` INT NOT NULL COMMENT 'Describes the charge type, Room, Meal, etc. Types are maintained in TYPE_NAME',
  `ChargeDescription` VARCHAR(255) NULL COMMENT 'Note field about the reason for the charge',
  `Amount` DECIMAL(12,2) NOT NULL DEFAULT 0 COMMENT 'Actual Charge Amount',
  `ChargeDate` DATETIME NOT NULL COMMENT 'Date/Time that the charge was incurred',
  `DueDate` DATETIME NULL COMMENT 'Field to hold when the charge is due, which is normally the anticipated checkout date.  Used for determining the status of customers',
  `PaidDate` DATETIME NULL COMMENT 'Date that the charge was paid for',
  PRIMARY KEY (`ChargeNum`),
  CONSTRAINT `fk_STAY_CHARGES_STAY1`
    FOREIGN KEY (`StayID`)
    REFERENCES `STAY` (`StayID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `STAY_CHARGES_ChargeType_FK`
    FOREIGN KEY (`ChargeType`)
    REFERENCES `TYPE_NAME` (`TypeNameID`)
    ON DELETE RESTRICT
    ON UPDATE RESTRICT)
ENGINE = InnoDB
COMMENT = 'This table logs all the charges that are accumulated against' /* comment truncated */ /* a stay/room*/;

CREATE INDEX `STAY_CHARGES_ChargeType_FK_idx` ON `STAY_CHARGES` (`ChargeType` ASC);


-- -----------------------------------------------------
-- Table `MAINTENANCE_TICKET`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `MAINTENANCE_TICKET` ;

CREATE TABLE IF NOT EXISTS `MAINTENANCE_TICKET` (
  `MaintTicketID` INT NOT NULL AUTO_INCREMENT COMMENT 'Surrogate Key to record the maintenance transaction',
  `RoomID` INT NOT NULL COMMENT 'Room that the maintenance will be performed on',
  `StartDate` DATETIME NOT NULL COMMENT 'When the maintenance window should start.  Reservation system will use this value to check availablility',
  `EndDate` DATETIME NULL COMMENT 'Used to record when the maintenance is actually complete.  Used to check availability when assigning rooms.',
  `AnticipatedEndDate` DATETIME NOT NULL COMMENT 'When the room should be available for use again; used for scheduling/reservations.  On Cleaning, this is set to 3:59',
  `MaintenanceType` INT NOT NULL COMMENT 'Description of the maintenance that is going to be perfomed.  Foreign key.',
  `TaskDescription` VARCHAR(255) NULL COMMENT 'Used to allow specific instructions to the employee who will be performing the maintenance',
  PRIMARY KEY (`MaintTicketID`),
  CONSTRAINT `MAINTENANCE_TICKET_RoomID_FK`
    FOREIGN KEY (`RoomID`)
    REFERENCES `ROOM` (`RoomID`)
    ON DELETE RESTRICT
    ON UPDATE NO ACTION,
  CONSTRAINT `MAINTENANCE_TICKET_MaintenanceType_FK`
    FOREIGN KEY (`MaintenanceType`)
    REFERENCES `TYPE_NAME` (`TypeNameID`)
    ON DELETE RESTRICT
    ON UPDATE RESTRICT)
ENGINE = InnoDB
COMMENT = 'Maintains the record of maintenance events that occur on roo' /* comment truncated */ /*ms, including scheduled future maintenance, and cleanings.*/;

CREATE INDEX `fk_MAINTENANCE_TICKET_ROOM1_idx` ON `MAINTENANCE_TICKET` (`RoomID` ASC);

CREATE INDEX `MAINTENANCE_TICKET_MaintenanceType_FK_idx` ON `MAINTENANCE_TICKET` (`MaintenanceType` ASC);


-- -----------------------------------------------------
-- Table `MAINTENACE_LOG`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `MAINTENACE_LOG` ;

CREATE TABLE IF NOT EXISTS `MAINTENACE_LOG` (
  `LogID` INT NOT NULL AUTO_INCREMENT COMMENT 'Surrogate key to record the transaction',
  `MaintTicketID` INT NOT NULL COMMENT 'Foreign key to the parent Maintence_Ticket record',
  `MaintenaceDate` DATETIME NOT NULL COMMENT 'Date/time that the maintenance was performed',
  `EmployeeID` INT NOT NULL COMMENT 'Employee who performed the maintenance',
  `Notes` VARCHAR(255) NULL COMMENT 'Notes the employee enters about the maintenance',
  PRIMARY KEY (`LogID`, `MaintTicketID`),
  CONSTRAINT `MAINTENACE_LOG_MaintTicketID_FK`
    FOREIGN KEY (`MaintTicketID`)
    REFERENCES `MAINTENANCE_TICKET` (`MaintTicketID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB
COMMENT = 'Table used to record details of maintenance performed.  Each' /* comment truncated */ /* maintenance ticket could have multiple entries in the log*/;


-- -----------------------------------------------------
-- Table `EMPLOYEE`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `EMPLOYEE` ;

CREATE TABLE IF NOT EXISTS `EMPLOYEE` (
  `EmployeeID` INT NOT NULL AUTO_INCREMENT COMMENT 'Surrogate Key',
  `FirstName` VARCHAR(45) NULL COMMENT 'Employee\'s First Name',
  `LastName` VARCHAR(45) NULL COMMENT 'Employee\'s Last name',
  `HireDate` DATETIME NULL COMMENT 'Date the Employee was hired',
  `JobTitle` VARCHAR(45) NULL COMMENT 'Title currently assigned to Employee --intentionally left open at this point',
  PRIMARY KEY (`EmployeeID`))
ENGINE = InnoDB
COMMENT = 'Simplified  table to record employee information';


-- -----------------------------------------------------
-- Table `CARD_ASSIGNMENT`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CARD_ASSIGNMENT` ;

CREATE TABLE IF NOT EXISTS `CARD_ASSIGNMENT` (
  `CardNumber` INT NOT NULL COMMENT 'Unique Number assigned to a Card.  Assumed that this is the number that is able to be read by the card readers (instead of a secondary number)',
  `CustomerID` INT NULL COMMENT 'When cards are assigned to a customer, this field will point to the customer',
  `EmployeeID` INT NULL COMMENT 'When a card is assigned to an employee, this points to the employee record',
  `AssignedDate` DATETIME NOT NULL COMMENT 'Date/time that the card was assigned to the guest/employee',
  `ExpirationDate` DATETIME NULL COMMENT 'When card is returned/reported lost/stolen.',
  PRIMARY KEY ( `CardNumber`),
  CONSTRAINT `CARD_ASSIGNMENT_CustomerID_FK`
    FOREIGN KEY (`CustomerID`)
    REFERENCES `CUSTOMER` (`CustomerID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `CARD_ASSIGNMENT_EmployeeID`
    FOREIGN KEY (`EmployeeID`)
    REFERENCES `EMPLOYEE` (`EmployeeID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB
COMMENT = 'Intersecting table used to record a card assignment to eithe' /* comment truncated */ /*r a customer or employee*/;

CREATE INDEX `fk_CARD_ASSIGNMENT_EMPLOYEE1_idx` ON `CARD_ASSIGNMENT` (`EmployeeID` ASC);

DESCRIBE ROOM;
-- -----------------------------------------------------
-- Table `CARD_LOC_LOG`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `CARD_LOC_LOG` ;

CREATE TABLE IF NOT EXISTS `CARD_LOC_LOG` (
  `CardNumber` INT NOT NULL COMMENT 'CardNumber of the Employee/Customer',
  `Timestamp` DATETIME NOT NULL COMMENT 'Time that the device was swiped',
  `RoomID` INT NOT NULL COMMENT 'RoomID (location) that the swipe occured',
  PRIMARY KEY (`CardNumber`, `Timestamp`),
  CONSTRAINT `CARD_LOC_LOG_CardNumber_FK`
    FOREIGN KEY (`CardNumber`)
    REFERENCES `CARD_ASSIGNMENT` (`CardNumber`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `CARD_LOC_LOG_RoomID_FK`
    FOREIGN KEY (`RoomID`)
    REFERENCES `ROOM` (`RoomID`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB
COMMENT = 'Table is a transactional table used simply to record everyti' /* comment truncated */ /*me that a card is swiped.  This allows locations of staff and customers to be recorded*/;

CREATE INDEX `fk_CARD_LOC_LOG_CARD_ASSIGNMENT1_idx` ON `CARD_LOC_LOG` (`CardNumber` ASC);

CREATE INDEX `fk_CARD_LOC_LOG_ROOM1_idx` ON `CARD_LOC_LOG` (`RoomID` ASC);


-- -----------------------------------------------------
-- Table `BUILDING_WING_FEATURES`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `BUILDING_WING_FEATURES` ;

CREATE TABLE IF NOT EXISTS `BUILDING_WING_FEATURES` (
  `BuildingID` INT NOT NULL,
  `WingID` INT NOT NULL,
  `FeatureID` INT NOT NULL COMMENT 'Lists the different features that the wing can have (Indoor Pool, Outdoor Pool, Loading Dock, etc.)',
  `ProximityID` INT NOT NULL COMMENT 'Values such as Adjacent, Near, Unavailable',
  PRIMARY KEY (`BuildingID`, `WingID`, `FeatureID`),
  CONSTRAINT `BUILDWING_FEATURES_BUILDING_WING_fk`
    FOREIGN KEY (`BuildingID` , `WingID`)
    REFERENCES `BUILDING_WING` (`BuildingID` , `WingID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `BUILDWING_FEATURES_FeatureID_fk`
    FOREIGN KEY (`FeatureID`)
    REFERENCES `TYPE_NAME` (`TypeNameID`)
    ON DELETE RESTRICT
    ON UPDATE RESTRICT,
  CONSTRAINT `BUILDWING_FEATURES_ProximityID_fk`
    FOREIGN KEY (`ProximityID`)
    REFERENCES `TYPE_NAME` (`TypeNameID`)
    ON DELETE RESTRICT
    ON UPDATE RESTRICT)
ENGINE = InnoDB
COMMENT = 'Detail table of Building/Wing that allows the assignment of ' /* comment truncated */ /*multiple features such as indoor pool, outdoor pool, parking*/;

CREATE INDEX `fk_BUILDWING_FEATURES_TYPE_NAME1_idx` ON `BUILDING_WING_FEATURES` (`FeatureID` ASC);

CREATE INDEX `fk_BUILDWING_FEATURES_TYPE_NAME1_idx1` ON `BUILDING_WING_FEATURES` (`ProximityID` ASC);

USE `hollyhotel`;

-- -----------------------------------------------------
-- Table `USERS`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `USERS` ;

CREATE TABLE IF NOT EXISTS `USERS` (
  `userID` INT NOT NULL AUTO_INCREMENT COMMENT 'Surrogate Key',
  `username` VARCHAR(50) NOT NULL COMMENT 'Login ID',
  `password` VARCHAR(45) NOT NULL COMMENT 'Encrypted',
  `email` VARCHAR(255) NULL COMMENT 'Allow to store email address',
  `create_time` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'Time Stamp',
  PRIMARY KEY (`userID`))
COMMENT = 'Simple table to implement basic authentication';

-- -----------------------------------------------------
-- Table `CC_INFO`
-- -----------------------------------------------------

DROP TABLE IF EXISTS `CC_INFO`;

CREATE TABLE IF NOT EXISTS `CC_INFO` (
  `CCID` INT NOT NULL AUTO_INCREMENT COMMENT 'Surrogate Key',
  `CustomerID` INT NOT NULL COMMENT 'Links Customer to the Credit Card',
  `AddressSeq` INT NOT NULL COMMENT 'Links Credit Card to billing address.  If the same as the primary then 0, otherwise add new sequence',
  `NameOnCard` VARCHAR(100) NULL,
  `CreditCardNetwork` VARCHAR(45) NULL COMMENT 'Visa, Mastercard, Discover',
  `CCNumber` VARCHAR(16) NOT NULL COMMENT 'Credit card Number, Normally12 digits',
  `ExpMonth` INT NULL COMMENT 'Expiration Month 1-12',
  `ExpYear` INT NULL COMMENT 'Expiration Year',
  PRIMARY KEY (`CCID`),
  INDEX `CC_INFO_CustAddrSeq_FK_idx` (`CustomerID` ASC, `AddressSeq` ASC),
  CONSTRAINT `CC_INFO_CustAddrSeq_FK`
    FOREIGN KEY (`CustomerID` , `AddressSeq`)
    REFERENCES `hollyhotel`.`ADDRESS` (`CustomerID` , `AddressSeq`)
    ON DELETE RESTRICT
    ON UPDATE RESTRICT,
  CONSTRAINT `CC_INFO_CustomerID`
    FOREIGN KEY (`CustomerID`)
    REFERENCES `hollyhotel`.`CUSTOMER` (`CustomerID`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Holds Credit Card Information (would not exist in this manne' /* comment truncated */ /*r in real life)*/

/***************************************************************************************************************************************************************/
delimiter $$

/***************************************************************************************************************************************************************
VIEWS

****************************************************************************************************************************************************************/
DROP VIEW IF EXISTS StdCustomerInfoVw $$

CREATE VIEW StdCustomerInfoVw AS
select
c.CustomerID
, c.FirstName
, c.LastName
, c.contactInfoConfidential

, a0.Address1 as BillToAddress1
, a0.Address2 as BillToAddress2
, a0.Address3 as BillToAddress3
, a0.Address4 as BillToAddress4
, a0.City as BillToCity
, a0.State as BillToState
, a0.Zip as BillToZip
, a0.Country as BillToCountry

, p0.PhoneNum as BillToPhoneNum

from Customer c
join address a0 on a0.CustomerID=c.CustomerID and a0.AddressSeq = 0
join phone p0 on p0.CustomerID=c.CustomerID and p0.PhoneNumSeq = 0

where c.CustomerType = 'C'

; $$

/*************************************************************************************************************************************/
DROP VIEW IF EXISTS BuildWingFeatVw $$

CREATE VIEW BuildWingFeatVw AS
SELECT BUILDINGID, WINGID
, GROUP_CONCAT(f.Name order by f.Name) as Features
, GROUP_CONCAT(bwf.FeatureID order by bwf.FeatureID) as FeatureIDs
, Sum(f.UsageRank) as FeatureRank
From BUILDING_WING_FEATURES bwf
JOIN Type_Name f on f.TypeNameID=bwf.FeatureID

WHERE bwf.ProximityID not in (Select TypeNameID from Type_Name where UsageID='ProximityID' and Name = 'None')
GROUP by BuildingID, WingId; $$

/**************************************************************************************************************************************/
DROP VIEW IF EXISTS SuiteBedsVw $$

CREATE VIEW SuiteBedsVw AS

select 
r.ParentRoomID as RoomID
, rb.BedType
, rb.BedSequence
from room r
join room pr on pr.roomid=r.ParentRoomID
join room_detail rd on rd.roomid=pr.roomid and rd.RoomType in (Select TypeNameID from Type_Name where UsageID='RoomType' and Name = 'Suite')
join room_beds rb on rb.RoomID=r.RoomID

UNION

SELECT
r.RoomID
, rb.BedType
, rb.BedSequence
from room r
join room_detail rd on rd.roomid=r.roomid and rd.RoomType in (Select TypeNameID from Type_Name where UsageID='RoomType' and Name = 'Suite')
join room_beds rb on rb.RoomID=r.RoomID;

$$
/*****************************************************************************************************************************************/
DROP VIEW IF EXISTS SuiteBedsSummaryVw $$

CREATE VIEW SuiteBedsSummaryVw AS
SELECT 
sb.RoomID
, COUNT(sb.BedSequence) as Qty
, MIN(sb.BedSequence) as BedSequence
, sb.BedType
from SuiteBedsVw sb group by sb.RoomID, sb.BedType; $$

/*****************************************************************************************************************************************/


DROP VIEW IF EXISTS SuiteRoomInfoVw $$
 
CREATE VIEW SuiteRoomInfoVw AS
Select
  r.RoomID
, r.RoomNumber
, b.Name as BuildingName
, w.Name as WingName
, r.Floor as FloorNumber
, case when wf.SmokingProhibited = 1 then 0 when rd.PermitSmoking = 0 then 0 else 1 end as SmokingAllowed
, GROUP_CONCAT(concat(rb.Qty, '-',bd.Name) order by rb.BedType) as Beds
, GROUP_CONCAT(distinct rb.BedType order by rb.BedSequence) as BedTypes
, bwf.Features
, bwf.FeatureIds
, bwf.FeatureRank+ sum(bd.UsageRank) as RoomRank
, rd.Rate
, rd.Capacity
from room r
join Type_Name b on b.TypeNameID = r.BuildingID
join Type_Name w on w.TypeNameID = r.WingID
join WING_FLOOR wf on wf.BuildingId = r.BuildingID and wf.WingId=r.WingID and wf.FloorNumber=r.Floor
join BuildWingFeatVw bwf on bwf.BuildingID=r.BuildingId and bwf.WingId=r.WingId
join ROOM_DETAIL rd on r.RoomID=rd.RoomID and RoomType in (Select TypeNameID from Type_Name where UsageID='RoomType' and Name = 'Suite')
join SuiteBedsSummaryVw  rb on rb.RoomID=r.RoomId
JOIN Type_Name bd on bd.TypeNameID=rb.BedType

 group by r.RoomID ;$$

/**************************************************************************************************************************************/
 DROP VIEW IF EXISTS SleepBedsSummaryVw $$

CREATE VIEW SleepBedsSummaryVw AS
SELECT 
sb.RoomID
, COUNT(sb.BedSequence) as Qty
, MIN(sb.BedSequence) as BedSequence
, sb.BedType
from room_beds sb group by sb.RoomID, sb.BedType; $$

/*************************************************************************************************************************************/
DROP VIEW IF EXISTS SleepRoomInfoVw $$

CREATE VIEW SleepRoomInfoVw AS

Select
  r.RoomID
, r.RoomNumber
, b.Name as BuildingName
, w.Name as WingName
, r.Floor as FloorNumber
, case when wf.SmokingProhibited = 1 then 0 when rd.PermitSmoking = 0 then 0 else 1 end as SmokingAllowed
, GROUP_CONCAT(concat(rb.Qty, '-',bd.Name) order by rb.BedType) as Beds
, GROUP_CONCAT(rb.BedType order by rb.BedSequence) as BedTypes
, bwf.Features
, bwf.FeatureIds
, bwf.FeatureRank+ sum(bd.UsageRank) as RoomRank
, rd.Rate
, rd.Capacity
from room r
join Type_Name b on b.TypeNameID = r.BuildingID
join Type_Name w on w.TypeNameID = r.WingID
join WING_FLOOR wf on wf.BuildingId = r.BuildingID and wf.WingId=r.WingID and wf.FloorNumber=r.Floor
join BuildWingFeatVw bwf on bwf.BuildingID=r.BuildingId and bwf.WingId=r.WingId

join ROOM_DETAIL rd on r.RoomID=rd.RoomID and RoomType in (Select TypeNameID from Type_Name where UsageID='RoomType' and Name = 'Sleeping')
JOIN SleepBedsSummaryVw rb on rb.RoomID=r.RoomID
JOIN Type_Name bd on bd.TypeNameID=rb.BedType

group by r.RoomID
; $$

/****************************************************************************************************************************************/
DROP VIEW IF EXISTS MeetingRoomInfoVw $$

CREATE VIEW MeetingRoomInfoVw AS
Select
  r.RoomID
, r.RoomNumber
, b.Name as BuildingName
, w.Name as WingName
, r.Floor as FloorNumber
, case when wf.SmokingProhibited = 1 then 0 when rd.PermitSmoking = 0 then 0 else 1 end as SmokingAllowed
, GROUP_CONCAT(concat(rb.Qty, '-',bd.Name) order by rb.BedType) as Beds
, GROUP_CONCAT(rb.BedType order by rb.BedSequence) as BedTypes
, bwf.Features
, bwf.FeatureIds
, bwf.FeatureRank+ sum(bd.UsageRank) as RoomRank
, rd.Rate
, rd.Capacity
from room r
join Type_Name b on b.TypeNameID = r.BuildingID
join Type_Name w on w.TypeNameID = r.WingID
join WING_FLOOR wf on wf.BuildingId = r.BuildingID and wf.WingId=r.WingID and wf.FloorNumber=r.Floor
join BuildWingFeatVw bwf on bwf.BuildingID=r.BuildingId and bwf.WingId=r.WingId
join ROOM_DETAIL rd on r.RoomID=rd.RoomID and RoomType in (Select TypeNameID from Type_Name where UsageID='RoomType' and Name = 'Meeting')
JOIN SleepBedsSummaryVw rb on rb.RoomID=r.RoomID
JOIN Type_Name bd on bd.TypeNameID=rb.BedType

group by r.RoomID;
$$
/*************************************************************************************************************************************/



DROP VIEW IF EXISTS RoomsBookedVw $$

CREATE VIEW RoomsBookedVw AS
select   RoomID, CheckIn  AS StartDate, AnticipatedCheckOut AS EndDate
from STAY
WHERE CheckOut is null

UNION
#BOOK PARENT ROOMS WHEN CHILD IS CHECK OUT
select   DISTINCT ParentRoomID as RoomID, CheckIn  AS StartDate, AnticipatedCheckOut AS EndDate
from STAY s
join room r on r.ROOMID=s.RoomID
WHERE CheckOut is null and r.ParentRoomID is not null

UNION
#BOOK CHILDREN WHEN PARENT IS CHECK OUT
SELECT r.RoomID, CheckIn  AS StartDate, AnticipatedCheckOut AS EndDate
from STAY s
join room r on r.ParentRoomID=s.RoomID
WHERE CheckOut is null

UNION
# RESERVATIONS
SELECT RoomID, StartDate, EndDate
from RESERVATION
WHERE RoomID is not null and IFNULL(ConvertedToStay,0) = 0

UNION
#BOOK PARENT ROOMS WHEN CHILD IS RESERVED
SELECT DISTINCT r.ParentRoomID as RoomID, StartDate, EndDate
from RESERVATION res
JOIN ROOM r on r.RoomID=res.RoomID
WHERE r.ParentRoomID is not null and IFNULL(ConvertedToStay,0) = 0

UNION
#BOOK CHILDREN ROOMS WHEN PARENT IS RESERVED
SELECT DISTINCT r.RoomID, StartDate, EndDate
from RESERVATION res
JOIN ROOM r on r.ParentRoomID=res.RoomID
WHERE r.ParentRoomID is not null and IFNULL(ConvertedToStay,0) = 0


###MAINTENANCE
UNION
SELECT ROOMID, StartDate, AnticipatedEndDate
from MAINTENANCE_TICKET
WHERE EndDate is NULL

UNION
#BOOK PARENT ROOMS WHEN CHILD IS IN MAINT
SELECT   R.PARENTROOMID AS ROOMID, mt.StartDate, mt.AnticipatedEndDate
from MAINTENANCE_TICKET mt
JOIN ROOM R ON R.ROOMID=MT.ROOMID
WHERE EndDate is NULL

UNION
#BOOK CHILD WHEN PARENT IS IN MAINT
SELECT  R.ROOMID, mt.StartDate, mt.AnticipatedEndDate
from MAINTENANCE_TICKET mt
JOIN ROOM R ON R.PARENTROOMID=MT.ROOMID
WHERE EndDate is NULL
; $$

/***************************************************************************************************************************************/
DROP VIEW IF EXISTS ResFeaturesVw $$

CREATE VIEW ResFeaturesVw AS
select ReservationID, BedFeatureID as Bed_FeatureID, ProximityID, count(ReservationID) as Qty from res_features group by ReservationID, BedFeatureID, ProximityID
Union
select 
r.RoomID, bwf.FeatureID as Bed_FeatureID, bwf.ProximityID, 1 as Qty
from room r
join BUILDING_WING_FEATURES bwf on bwf.BuildingID=r.BuildingID and bwf.WingID=r.WingID ;

$$

/******************************************************************************************************************************************************/
DROP VIEW IF EXISTS roomfeaturesvw $$

CREATE VIEW roomfeaturesvw AS 
select RoomID AS RoomID
,BedType AS Bed_FeatureID
,0 AS ProximityID
,count(RoomID) AS Qty 
from room_beds 
group by RoomID,BedType 
union 
select r.RoomID AS RoomID
,bwf.FeatureID AS Bed_FeatureID
,bwf.ProximityID AS ProximityID
,1 AS Qty 
from 
room r 
join building_wing_features bwf on bwf.BuildingID = r.BuildingID and bwf.WingID = r.WingID
;$$

/************************************************************************************************************************************************************/

DROP VIEW IF EXISTS ReservationInfoVw $$

CREATE VIEW ReservationInfoVw AS
SELECT 
r.ReservationID
,r.ParentResID
,r.BillToID
,c.FirstName as BillToFirstName
,c.LastName  as BillToLastName
, r.GuestID
, c2.FirstName as GuestFirstName
, c2.LastName as GuestLastName
, r.EventID
, e.EventName
, e.HostID
, c3.FirstName as HostFirstName
, c3.LastName as HostLastName
, r.RoomType
, rt.Name as RoomTypeName
, r.StartDate
, r.EndDate
, r.Rate
, r.Deposit
, r.RoomID
, r.Smoking
, r.ConvertedToStay

, GROUP_CONCAT(concat(rf.Bed_FeatureID,',',rf.ProximityID) SEPARATOR'|')  as Features
, GROUP_CONCAT(case rf.qty when 1 then tn.Name else concat(rf.qty,'-', tn.Name,'s') end order by rf.Bed_FeatureID) as Feature_Description

FROM RESERVATION r
JOIN ResFeaturesVw rf on rf.ReservationID=r.ReservationID
JOIN TYPE_NAME tn on rf.Bed_FeatureID=TypeNameID
JOIN CUSTOMER c on c.CustomerID=r.BillToID
Left Outer Join CUSTOMER c2 on c2.CustomerID=r.GuestID
LEFT Outer Join `EVENT` e on e.EventID=r.EventID
LEFT OUTER JOIN CUSTOMER c3 on c3.CustomerID=e.HostID
JOIN TYPE_NAME rt on rt.TypeNameID=r.RoomType

WHERE R.ConvertedToStay = 0
and r.EndDate >= NOW()
group by r.ReservationID

;
$$

/*************************************************************************************************************************************/
DROP VIEW IF EXISTS `StayInfoVw` $$

CREATE VIEW `StayInfoVw` AS
SELECT 
s.StayID
,s.BillToID
,c.FirstName as BillToFirstName
,c.LastName  as BillToLastName
, s.GuestID
, c2.FirstName as GuestFirstName
, c2.LastName as GuestLastName
, s.EventID
, e.EventName
, e.HostID
, c3.FirstName as HostFirstName
, c3.LastName as HostLastName
, s.ReservationID
, r.Rate	ReservationRate
, rm.Rate	RoomRate
, s.RoomID
, room.RoomNumber
, s.RoomType
, rt.Name as RoomTypeName
, s.CheckIn
, s.AnticipatedCheckOut
, s.CheckOut

, GROUP_CONCAT(concat(rf.Bed_FeatureID,',',rf.ProximityID) SEPARATOR'|')  as Features
, GROUP_CONCAT(case rf.qty when 1 then tn.Name else concat(rf.qty,'-', tn.Name,'s') end order by rf.Bed_FeatureID) as Feature_Description

FROM STAY s
JOIN RoomFeaturesVw rf on rf.RoomID=s.RoomID
JOIN TYPE_NAME tn on rf.Bed_FeatureID=TypeNameID
JOIN CUSTOMER c on c.CustomerID=s.BillToID
Left Outer Join CUSTOMER c2 on c2.CustomerID=s.GuestID
LEFT Outer Join `EVENT` e on e.EventID=s.EventID
LEFT OUTER JOIN CUSTOMER c3 on c3.CustomerID=e.HostID
LEFT OUTER JOIN RESERVATION r on r.ReservationID=s.ReservationID
JOIN TYPE_NAME rt on rt.TypeNameID=s.RoomType
JOIN ROOM_DETAIL rm on rm.RoomID=s.RoomID and rm.RoomType=s.RoomType
join ROOM  on room.RoomID=s.RoomID

WHERE IFNULL(s.Checkout,NOW()) >= DATE_ADD(NOW(), INTERVAL -14 DAY)
group by s.StayID;$$ 


/*******************************************************************************************************************************************/
DROP VIEW IF EXISTS `StayChargesVw` $$

CREATE VIEW `StayChargesVw` AS
SELECT 
sc.StayID
, s.RoomID
, rm.RoomNumber
, sc.ChargeTo
, c.FirstName 
, c.LastName
, sc.ChargeType
, ct.Name as ChargeDesc
, sc.ChargeDescription
, sc.Amount
, sc.ChargeDate
, sc.DueDate
, sc.PaidDate

from STAY_CHARGES sc
join TYPE_NAME ct on ct.TypeNameID=sc.ChargeType
join STAY s on s.StayID-sc.StayID
join ROOM rm on rm.RoomID=s.RoomID
JOIN CUSTOMER c on c.CustomerID=sc.ChargeTo

WHERE IFNULL(s.Checkout,NOW()) >= DATE_ADD(NOW(), INTERVAL -14 DAY) 
#COMMENT 'USED TO SUMMARIZE CHARGES WITHOUT CREATING JOINS IN THE UI'
;$$

/************************************************************************************/
DROP VIEW IF EXISTS `OpenMaintTicketsVw` $$

CREATE VIEW `OpenMaintTicketsVw` AS

SELECT 
mt.MaintTicketID
, mt.RoomID
, r.RoomNumber
, mt.StartDate
, mt.AnticipatedEndDate
, mt.MaintenanceType
, tn.Name as MaintTypeDesc
, mt.TaskDescription
FROM MAINTENANCE_TICKET mt
JOIN ROOM r  on r.RoomID=mt.RoomID
join Type_Name tn on tn.TypeNameID=mt.MaintenanceType
where EndDate is null;$$


/***************************************************************************************************************************************************************
STORED PROCEDURES

****************************************************************************************************************************************************************/
DROP PROCEDURE IF EXISTS `InsUpStdCustomerSp`; $$

CREATE PROCEDURE `InsUpStdCustomerSp` (
  CustomerID  INT
, FirstName varchar(30)
, LastName varchar(30)
, ContactInfoconfidential tinyint

, BillToAddress1 VARCHAR(45)
, BillToAddress2 VARCHAR(45)
, BillToAddress3 VARCHAR(45)
, BillToAddress4 VARCHAR(45)
, BillToCity VARCHAR(45)
, BillToState VARCHAR(3)
, BillToZip   VARCHAR(10)
, BillToCountry VARCHAR(45)

, BillToPhoneNum VARCHAR(10)

)
BEGIN
	if FirstName is not null and LastName is not null then
    Begin
		SET ContactInfoConfidential =IFNULL(ContactInfoConfidential,0);
        IF CustomerID is NULL THEN
			BEGIN
            INSERT INTO CUSTOMER (FirstName, LastName, OrganizationName, ContactInfoConfidential) Values(FirstName, LastName, '', ContactInfoConfidential);
			SELECT LAST_INSERT_ID() into CustomerID;
            END;
		ELSE
			BEGIN
            UPDATE CUSTOMER as c SET
						c.FirstName = Firstname
					   , c.LastName = LastName
                       , c.ContactInfoConfidential = ContactInfoConfidential
				where c.CustomerID = CustomerID;
			END;
        END IF; #CUSTOMERID IS NULL

		INSERT INTO Address (CustomerID, AddressSeq, Address1, Address2, Address3, Address4, City, State, Zip, Country) VALUES( CustomerID, 0, BillToAddress1, BillToAddress2, BillToAddress3, BillToAddress4, BillToCity, BillToState, BillToZip, BillToCountry)
			ON DUPLICATE KEY UPDATE
				Address1 = BillToAddress1,
                Address2 = BillToAddress2,
                Address3 = BillToAddress3,
                Address4 = BillToAddress4,
                City = BillToCity,
                State = BillToState,
                Zip = BillToZip,
                Country = BillToCountry
                ;

        INSERT INTO Phone(CustomerID, PhoneNumSeq, PhoneNum) VALUES(CustomerID,0,BillToPhoneNum)
			ON DUPLICATE KEY UPDATE
            PhoneNum = BillToPhoneNum;
		End;

    end if;  # firstname/lastname

END; $$

/*************************************************************************************************************************************************************/
DROP PROCEDURE IF EXISTS `GetAvailableRoomsSp`; $$

CREATE PROCEDURE `GetAvailableRoomsSp` (

pStartDate		DateTime
,pEndDate		DateTime
, pRoomType		INT
, pSmoking		INT
, pRequirements	Varchar(255))
Begin
  
   #start by parsing the pRequirements into a temp table (wanted to use an table defined function, but  . . . .)
  	DECLARE PrevDel INT Default 1;
	DECLARE NextDel INT Default 1;
    DECLARE i		INT DEFAULT 0;
	DECLARE str CHAR(5);

DROP TABLE IF EXISTS tmp_FEATURES;
CREATE TEMPORARY TABLE  tmp_FEATURES ( FeatureSequence	Int	, Bed_FeatureID		Int	, ProximityID		Int);
DROP TABLE IF EXISTS tmp_unmachedrooms;
CREATE TEMPORARY TABLE tmp_unmachedrooms(RoomID INT);

if length(ifnull(pRequirements,''))>3 then
BEGIN
    
	parse_loop: LOOP
		Set NextDel = Locate('|',pRequirements,PrevDel);
		if NextDel = 0 then 
			SET NextDel = LENGTH(pRequirements)+1;
		elseif NextDel =1 then 
			begin
			Set PrevDel = 2;
			Set NextDel = Locate('|',pRequirements,PrevDel);
			end;
		end if;
		Set str = SUBSTR(pRequirements,PrevDel,NextDel-PrevDel);
	if str='' then
		LEAVE parse_loop;
	end if;

	INSERT INTO tmp_FEATURES (Bed_FeatureID, ProximityID, FeatureSequence) values(SUBSTRING_INDEX(str,',',1),SUBSTRING_INDEX(str,',',-1),i);
		Set PrevDel = NextDel+1;
        Set i=i+1;
	end LOOP parse_loop;
    
    ############create a temp table with a list where of all rooms that don't meet the requirement criteria
 
     
    INSERT INTO tmp_unmachedrooms 
    SELECT DISTINCT R.ROOMID
		FROM ROOM R
		JOIN tmp_Features tf
		LEFT OUTER JOIN ROOMFEATURESVW RFV on r.ROOMID=RFV.ROOMID AND tf.Bed_FeatureID=RFV.Bed_FeatureID
		where RFV.ROOMID IS NULL;
            INSERT INTO tmp_unmachedrooms 
     #FOR THE SUITES       
    SELECT DISTINCT R.PARENTROOMID
		FROM ROOM R
		JOIN tmp_Features tf
		LEFT OUTER JOIN ROOMFEATURESVW RFV on r.ROOMID=RFV.ROOMID AND tf.Bed_FeatureID=RFV.Bed_FeatureID
		where RFV.ROOMID IS NULL;
END;  #if pFeatures <3
END IF;
    
   
	IF pRoomType = (Select TypeNameID from Type_Name where UsageID = 'RoomType' and Name = 'Sleeping') then
    BEGIN
		SELECT 
			sr.RoomID, sr.RoomNumber, sr.BuildingName, sr.WingName, sr.FloorNumber, sr.SmokingAllowed, sr.capacity, sr.Beds, sr.BedTypes, sr.Features, sr.FeatureIDs
        FROM SleepRoomInfoVw sr
        where sr.RoomID not in (Select RoomID from RoomsBookedVw rb where pStartDate between rb.StartDate and rb.EndDate or pEndDate between rb.StartDate and rb.EndDate)
        and 	sr.RoomID not in (select RoomID from tmp_unmachedrooms)
        and pSmoking = sr.SmokingAllowed ;
    
    END;
    ELSEIF pRoomType = (Select TypeNameID from Type_Name where UsageID = 'RoomType' and Name = 'Suite') then
		BEGIN
			SELECT 
				sr.RoomID, sr.RoomNumber, sr.BuildingName, sr.WingName, sr.FloorNumber, sr.SmokingAllowed, sr.capacity, sr.Beds, sr.BedTypes, sr.Features, sr.FeatureIDs
			FROM SuiteRoomInfoVw sr
			where sr.RoomID not in (Select RoomID from RoomsBookedVw rb where pStartDate between rb.StartDate and rb.EndDate or pEndDate between rb.StartDate and rb.EndDate)
			and 	sr.RoomID not in (select RoomID from tmp_unmachedrooms)
			and pSmoking = sr.SmokingAllowed ;
		
		END;
     ELSEIF pRoomType = (Select TypeNameID from Type_Name where UsageID = 'RoomType' and Name = 'Meeting') then
		BEGIN
			SELECT 
				sr.RoomID, sr.RoomNumber, sr.BuildingName, sr.WingName, sr.FloorNumber, sr.SmokingAllowed, sr.capacity, sr.Beds, sr.BedTypes, sr.Features, sr.FeatureIDs
			FROM MeetingRoomInfoVw sr
			where sr.RoomID not in (Select RoomID from RoomsBookedVw rb where pStartDate between rb.StartDate and rb.EndDate or pEndDate between rb.StartDate and rb.EndDate)
			and 	sr.RoomID not in (select RoomID from tmp_unmachedrooms);
			#and pSmoking = sr.SmokingAllowed 
		
		END;
    END IF;
	

END $$

$$
/*************************************************************************************************************************************************************/
DROP PROCEDURE IF EXISTS `InsUpStdReservationSp`; $$

CREATE PROCEDURE `InsUpStdReservationSp` (
 pReservationID INT
, pParentResID	INT
, pBillToID		INT
, pGuestID		INT
, pEventID		INT
, pRoomType		INT
, pStartDate		DATETIME
, pEndDate		DATETIME
, pRate			DEC(12,2)
, pDeposit		DEC(12,2)
, pRoomID		INT
, pSmoking		INT
, pFEATURES		VARCHAR(255)

)
BEGIN

	# parse out the text in pFEATURES into tmp_Res_Features

	DECLARE PrevDel INT Default 1;
	DECLARE NextDel INT Default 1;
    DECLARE i		INT DEFAULT 0;
	DECLARE str CHAR(5);

    DROP TABLE IF EXISTS tmp_RES_FEATURES;
	CREATE TEMPORARY TABLE  tmp_RES_FEATURES (
	ReservationID		Int
    , FeatureSequence	Int
	, Bed_FeatureID		Int
	, ProximityID		Int);
	parse_loop: LOOP
		Set NextDel = Locate('|',pFEATURES,PrevDel);
		if NextDel = 0 then
			SET NextDel = LENGTH(pFeatures)+1;
		elseif NextDel =1 then
			begin
			Set PrevDel = 2;
			Set NextDel = Locate('|',pFEATURES,PrevDel);
			end;
		end if;
		Set str = SUBSTR(pFEATURES,PrevDel,NextDel-PrevDel);
	if str='' then
		LEAVE parse_loop;
	end if;

	INSERT INTO tmp_RES_FEATURES (Bed_FeatureID, ProximityID, FeatureSequence) values(SUBSTRING_INDEX(str,',',1),SUBSTRING_INDEX(str,',',-1),i);
		Set PrevDel = NextDel+1;
        Set i=i+1;
	end LOOP parse_loop;

	IF pBillToId is not null then  #only really required input

		#LOOKUP VALUES FROM PARENT
		IF pParentResID is not Null then
		SELECT IFNULL(pEventID,EventID), IFNULL(pRoomType,RoomType), IFNULL(pStartDate,StartDate), IFNULL(pEndDate,EndDate), IFNULL(pRate, Rate), IFNULL(pFEATURES,FEATURES)
		INTO pEventID, pRoomType, pStartDate, pEndDate, pRate, pFeatures
		FROM ReservationSummaryVw ;
		END IF;

        IF pReservationID is Null then
			BEGIN
			INSERT INTO RESERVATION (ParentResID, BillToID, GuestID, EventID, RoomType, StartDate, EndDate, Rate, Deposit, RoomID, Smoking)
				VALUES (pParentResID, pBillToID, pGuestID, pEventID, pRoomType, pStartDate, pEndDate, pRate, pDeposit, pRoomID, pSmoking);
			SELECT LAST_INSERT_ID() into pReservationID;
			END;
        ELSE
			BEGIN
				UPDATE RESERVATION SET
						  ParentResID 	= pParentResID
                        , BillToID 		= pBillToID
                        , GuestID		= pGuestID
                        , EventID		= pEventID
                        , RoomType		= pRoomType
                        , StartDate		= pStartDate
                        , EndDate		= pEndDate
                        , Rate			= pRate
                        , Deposit		= pDeposit
                        , RoomID		= pRoomID
                        , Smoking		= pSmoking
				WHERE ReservationID=pReservationID;
            END;
        END IF; #pReservationID is Null


        #now set the room features.  better way of doing this, but this is the easiest to code
        DELETE FROM RES_FEATURES WHERE ReservationID = pReservationID;
        INSERT INTO RES_FEATURES (SELECT pReservationID, FeatureSequence, Bed_featureID, ProximityID from tmp_RES_FEATURES);


		END IF; #PBillToID is not null
        drop table tmp_RES_FEATURES;
 
End;$$
/*****************************************************************************************************************************************************************/


DROP PROCEDURE IF EXISTS `InsertStaySp`; $$

CREATE PROCEDURE `InsertStaySp` (
  pBillToID  INT
, pGuestID	INT
, pReservationID	INT
, pEventID		Int
, pRoomID	Int
, pRoomType Int
, pAnticipatedCheckOut	DateTime
, pRate DEC(12,2)
, pDeposit DEC(12,2)

)
BEGIN
	DECLARE StayID, StayLength, i INT;

	if pBillToID is not null then
    Begin
		IF pReservationID is Not NULL and pRoomID is Not Null THEN
			BEGIN
            SELECT
				IFNULL(pGuestID,r.GuestID)
            ,	IFNULL(pEventID,r.EventID)
            , 	IFNULL(pAnticipatedCheckOut, r.EndDate)
            , 	IFNULL(pRate,r.Rate)
            , 	IFNULL(pDeposit,r.Deposit)
            , 	IFNULL(pRoomType,r.RoomType)

            into pGuestID
			,	pEventID
            , 	pAnticipatedCheckOut
            ,	pRate
            , 	pDeposit
            ,	pRoomType
            FROM RESERVATION r where r.ReservationID=pReservationID;

            UPDATE RESERVATION SET ConvertedToStay = 1 where ReservationID = pReservationID;


            END;
		END IF;

		INSERT INTO STAY (BillToID, GuestID, ReservationID, EventID, RoomID, RoomType, CheckIn, AnticipatedCheckOut) values (pBillToID, pGuestID, pReservationID, pEventID, pRoomID, pRoomType, NOW(), pAnticipatedCheckOut);
		SELECT LAST_INSERT_ID() into StayID;
	
    
		SET STAYLENGTH = DATEDIFF(pAnticipatedCheckOut,CURDATE());
        SET i=0;
		WHILE i <STAYLENGTH DO 
        
        INSERT INTO STAY_CHARGES(STAYID, ChargeTo, ChargeType, Amount, ChargeDate, DueDate) 
        values (StayId, pBillToID, (SELECT TypeNameID from Type_Name where UsageID = 'ChargeType' and Name = 'Room Charges'),pRate, DATEADD(CURDATE(),i), pAnticipatedCheckOut);
		set i=i+1;
        END WHILE;

		IF IFNULL(pDeposit,0)<> 0 THEN
                INSERT INTO STAY_CHARGES(STAYID, ChargeTo, ChargeType, Amount, ChargeDate, DueDate) 
					values (StayId, pBillToID, (SELECT TypeNameID from Type_Name where UsageID = 'ChargeType' and Name = 'Deposit'),-1*pRate, Now(), pAnticipatedCheckOut);
        END IF;

		End;

    end if;  # billtoid, roomid

END; $$

/**********************************************************************************************************************************************************/

DROP PROCEDURE IF EXISTS `GetAvailablityByFeaturesSp`; $$

CREATE PROCEDURE `GetAvailablityByFeaturesSp` (
pStartDate 	DATETIME
, pEndDATE	DateTime
)
BEGIN
DECLARE cReservationID, cRoomType, cSmoking, BREAK, cExampleRoom, i int default 0;
DECLARE cRate		dec(12,2) default 0;

#MY SQL is so poor that you have to declare all before you process anything!!!!!!!
DECLARE reservation_cur CURSOR FOR
	select ReservationID , RoomType , Rate , Smoking
		FROM RESERVATION 
       where ROOMID IS NULL AND ConvertedToStay=0
       and (StartDate Between pStartDate and pEndDate or EndDate Between pStartDate and pEndDate);
       

DECLARE CONTINUE HANDLER FOR NOT FOUND SET BREAK= 1; #HANDLER FOR CURSOR AND SELECT INTO




#FIRST LOAD ALL THE AVAILABLE ROOMS
DROP TABLE IF EXISTS tmp_reservationmap;
CREATE TEMPORARY TABLE tmp_reservationmap (RoomsAvailable Int, SmokingAllowed Int, Beds VARCHAR(100), Rate DEC(12,2), Features Varchar(255), RoomRank INT, RoomFeatures Varchar(100), ExampleRoom int, RoomsReserved Int);

INSERT INTO tmp_reservationmap
SELECT 
	COUNT(sri.RoomID) as RoomsAvailable
	, SmokingAllowed
	, LTRIM(RTRIM(Beds)) AS BEDS
	, Rate
	, Features
	, RoomRank
	, Concat(BedTypes, ',',FeatureIDs) RoomFeatures
    , MIN(sri.RoomID) EXAMPLEROOM
	, 0
	from SleepRoomInfoVw sri
	left outer join RoomsBookedVw bk on bk.RoomId=sri.RoomID and (bk.StartDate Between pStartDate and pEndDate or bk.EndDate Between pStartDate and pEndDate)
	WHERE bk.RoomID is null
       
	Group by SmokingAllowed, sri.Beds, Features, RoomRank, Rate, BedTypes, FeatureIDs;
	#ORDER BY RATE#

#find a list of room types that the reservations will not work with
DROP TABLE IF EXISTS tmp_NonMatchingResRoom;
CREATE TEMPORARY TABLE tmp_NonMatchingResRoom (EXAMPLEROOM INT, RESERVATIONID INT);

INSERT INTO tmp_NonMatchingResRoom
select 
distinct
rm.ExampleRoom 
, rfw.ReservationID

from tmp_reservationmap rm
join ResFeaturesVW rfw
join Reservation r on r.ReservationID=rfw.ReservationID 
left outer join RoomFeaturesVw rfv on rm.ExampleRoom = rfv.RoomID and rfw.Bed_FeatureID=rfv.Bed_FeatureID and rfw.ProximityID<=rfv.ProximityID and rfw.Qty<=rfv.Qty

where rfv.RoomID is null
and r.ROOMID IS NULL AND ConvertedToStay=0 and (r.StartDate Between pStartDate and pEndDate or r.EndDate Between pStartDate and pEndDate)
;


#start working through the cursor
set BREAK=0;

OPEN reservation_cur;

get_reservation: LOOP
	
    fetch reservation_cur INTO cReservationId, cRoomType, cRate, cSmoking;
	
	IF break = 1 THEN LEAVE get_reservation; END IF;
     
	set i=i+1; #loop counter
    
    
	 Select 
    COALESCE(rm.EXAMPLEROOM,0) into cExampleRoom
     FROM tmp_reservationmap rm
     LEFT OUTER JOIN tmp_NonMatchingResRoom nmr on nmr.EXAMPLEROOM=rm.ExampleRoom and nmr.ReservationID=cReservationID
     WHERE nmr.EXAMPLEROOM is null
     and RoomsReserved<RoomsAvailable
     and SmokingAllowed = cSmoking
     ORDER BY ifnull(Rate,0), ifnull(RoomRank,0) LIMIT 1;
     
		IF BREAK=1 THEN SET BREAK= 0; END IF;  #IF NO MATCHING ROWS ARE FOUND IN THE SELECT INTO
   
    
     UPDATE tmp_reservationmap set RoomsReserved=RoomsReserved+1 where ExampleRoom=cExampleRoom;
     

END LOOP get_reservation;
CLOSE reservation_cur;

select * from tmp_reservationmap order by Rate, RoomRank;

#select i;
END;
$$

/*************************************************************************************************************************************************************/
DROP PROCEDURE IF EXISTS `CalcStayBalanceSp`; $$

CREATE PROCEDURE `CalcStayBalanceSp` (
pStayID		Int
, pCustomerID Int )
COMMENT 'marks all stay charges as paid if balance is zero '
BEGIN
 DECLARE BALANCE DEC(12,2);
 
 SELECT SUM(AMOUNT) into BALANCE FROM STAY_CHARGES WHERE StayID=pStayID and ChargeTo=pCustomerID;
 
 IF BALANCE = 0 THEN
	UPDATE STAY_CHARGES SET PaidDate = NOW() where PaidDate is NULL;
END IF;

END;$$


/*************************************************************************************************************************************/

DROP PROCEDURE IF EXISTS `MakePaymentSp`; $$

CREATE PROCEDURE `MakePaymentSp` (
pStayID		Int
, pCustomerID Int
, pAmount	DEC(12,2)
, pPaymentType Int
)
COMMENT 'inserts a PAYMENT record for a STAY, and calls CalcStayBalanceSp '
Begin
if (pStayID is not null and pCustomerID is not null )then
   begin

		if IFNULL(pPaymentType,0) =0 THEN
			SELECT TypeNameID into pPaymentType from Type_Name where UsageID = 'ChargeType' and Name = 'Payment';
		end if;


   INSERT INTO STAY_CHARGES(STAYID, ChargeTo, ChargeType, Amount, ChargeDate, DueDate, PaidDate) 
		values (StayId, pCustomerID, pPaymentType,-1*pAmount, Now(), Now(), Now());
    
   
   CALL CalcStayBalanceSp(pStayID, pCustomerID); #IF ZERO, CLOSES THE CHARGES
    end;
end if; 

End;$$
/*************************************************************************************************************************************/

DROP PROCEDURE IF EXISTS `GenerateCleaningRequestSp`; $$

CREATE PROCEDURE `GenerateCleaningRequestSp` (pRoomID int )
COMMENT 'inserts a Cleaning record for a room with an anticipated end time of 3pm'
BEGIN
    
    insert into MAINTENANCE_TICKET(RoomID, StartDate, AnticipatedEndDate, MaintenanceType) Values(pRoomID, Now(), ADDTIME(CONVERT(curdate(),DATETIME),'0 15:00:00.0'), (SELECT TASKNAMEID from TASK_NAME WHERE UsageID='MaintenanceType' and Name='Cleaning'));

END 
;$$


/*************************************************************************************************************************************/

DROP PROCEDURE IF EXISTS `CheckOutSp`; $$

CREATE PROCEDURE `CheckOutSp` (
pStayID int )
COMMENT 'closes out a stay and then calls GenerateCleaningRequestSp '
BEGIN
DECLARE vROOMID INT;

	SELECT RoomID into vROOMID from STAY WHERE STAYID=pStayID;
	UPDATE STAY SET CheckOut=NOW() WHERE StayID=pStayID;
    
    CALL GenerateCleaningRequestSp(vROOMID);

END;$$

/*************************************************************************************************************************************/

/********************************************************************************************/
DROP PROCEDURE IF EXISTS `ReassignRoomSp`; $$

CREATE PROCEDURE `ReassignRoomSp` (
pOldStayID	int
,pNewRoomID int
,pNewRate 	int)
COMMENT 'CLOSES OUT CURRENT ROOM, COPIES INFO TO NEW ROOM, AND CHARGES'

BEGIN
DECLARE vBillToID, vGuestID, vReservationID, vEventID, vRoomType, vNewStayID, vRoomCharges, vBalanceTransfer INT;
DECLARE vAnticipatedCheckOut DATETIME;
DECLARE vBALANCE, vDeposit DEC(12,2) default 0;

DECLARE CONTINUE HANDLER FOR SQLEXCEPTION ROLLBACK;
DECLARE CONTINUE HANDLER FOR SQLWARNING ROLLBACK;

SELECT TypeNameID into vRoomCharges from Type_Name where UsageID = 'ChargeType' and Name = 'Room Charges';
SELECT TypeNameID into vBalanceTransfer from Type_Name where UsageID = 'ChargeType' and Name = 'Balance Transfer';

START TRANSACTION;


# First set up a new stay with the new room, deposit is zero as we will copy those over
    Select BillToID, GuestID, ReservationID, EventID, RoomType, AnticipatedCheckOut, IFNULL(pNewRate,ReservationRate) INTO
    vBillToID, vGuestID, vReservationID, vEventID, vRoomType, vAnticipatedCheckOut, pNewRate
    FROM STAYINFOVW WHERE STAYID=pOldStayID;
    
    CALL InsertStaySp(vBillToID, vGuestID, vReservationID, vEventID, pNewRoom, vRoomType, vAnticipatedCheckOut, pNewRate, 0);
	SELECT LAST_INSERT_ID() into vNewStayID;
   
   
   
    #move charges from last room to this room BILLTO first and then GUEST --do not include today's room charge as it would be duplicated
    SELECT SUM(AMOUNT) INTO vBALANCE FROM STAY_CHARGES WHERE StayID=pOldStayID and ChargeTo=vBillToID and not(ChargeType=vRoomCharges and ChargeDate=CURDATE());
    IF IFNULL(vBALANCE,0)<>0 THEN
    INSERT INTO STAY_CHARGES(STAYID, ChargeTo, ChargeType, Amount, ChargeDate, DueDate) 
        values (vNewStayId, vBillToID, vBalanceTransfer,vBALANCE, CURDATE(), vAnticipatedCheckOut);
	END IF;

	#CREDIT THE ENTIRE BALANCE OF THE ROOM FOR THE BILLTO
 SELECT SUM(AMOUNT) INTO vBALANCE FROM STAY_CHARGES WHERE StayID=pOldStayID and ChargeTo=vBillToID ;
    IF IFNULL(vBALANCE,0)<>0 THEN
    INSERT INTO STAY_CHARGES(STAYID, ChargeTo, ChargeType, Amount, ChargeDate, DueDate, PaidDate) 
        values (pOldStayId, vBillToID, vBalanceTransfer,-1*vBALANCE, CURDATE(), vAnticipatedCheckOut, NOW());
	END IF;
 
	#Move the balance of the Guest
 SELECT SUM(AMOUNT) INTO vBALANCE FROM STAY_CHARGES WHERE StayID=pOldStayID and ChargeTo=vGuestID ;
    IF IFNULL(vBALANCE,0)<>0 THEN
    begin
    #create new
    INSERT INTO STAY_CHARGES(STAYID, ChargeTo, ChargeType, Amount, ChargeDate, DueDate) 
        values (vNewStayId, vGuestID, vBalanceTransfer,-vBALANCE, CURDATE(), vAnticipatedCheckOut);
	#close out old
	 INSERT INTO STAY_CHARGES(STAYID, ChargeTo, ChargeType, Amount, ChargeDate, DueDate, PaidDate) 
        values (pOldStayId, vGuestID, vBalanceTransfer,-1*vBALANCE, CURDATE(), vAnticipatedCheckOut, NOW());
	end;
	END IF;
 COMMIT;
	CALL CHECKOUTSP(pOldStayID);
	CALL CalStayBalanceSp(pOldStayId, vGuestID);
    CALL CalStayBalanceSp(pOldStayId, vBillToID);
 
 
END;$$


/*************************************************************************************************************************************/

DROP PROCEDURE IF EXISTS `UpdateMaintTicketSp`; $$

CREATE PROCEDURE `UpdateMaintTicketSp` (
pMaintTicketID  INT
, pMaintenaceDate	DATETIME
, pEMPLOYEEID	INT
, pNOTES		VARCHAR(255)
, pCloseTicket	INT)
COMMENT 'simple procedure that adds logs and can close a maintenance ticket (close ticket=1'
BEGIN
	INSERT INTO MAINTENANCE_LOG (MaintTicketID, MaintenanceDate, EmployeeID, Notes) Values(pMaintTicketID, pMaintenanceDate, pEmployeeID, pNotes);
    
    if pCloseTicket = 1 then
		UPDATE MAINTENANCE_TICKET SET EndDAte = pMaintenanceDate where MaintTicketID=pMaintTicketID and pMaintenanceDate>StartDate;
	end if;
END;$$


/***************************************************************************************************************************************************************
TRIGGERS

****************************************************************************************************************************************************************/
USE `hollyhotel`$$
DROP TRIGGER IF EXISTS `BUILDING_WING_BEFORE_INSERT` $$
USE `hollyhotel`$$
CREATE TRIGGER `BUILDING_WING_BEFORE_INSERT` BEFORE INSERT ON `BUILDING_WING`
  FOR EACH ROW
  BEGIN
	DECLARE msg varchar(255);

    IF NEW.BuildingID not in (select TypeNameID from TYPE_NAME where UsageID = 'BuildingID') then
		BEGIN
			SELECT IFNULL(`Name`,'') into msg from Type_Name where TypeNameID=NEW.BuildingID;
			SET msg = concat(msg, ' is not a valid Building');
			SIGNAL sqlstate '45000' SET message_text = msg;
		END;
    ELSEIF NEW.WingID not in (select TypeNameID from TYPE_NAME where UsageID = 'WingID') then
		BEGIN
			SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.WingID;
			SET msg = concat(msg, ' is not a valid Proximity Type');
			SIGNAL sqlstate '45000' SET message_text = msg;
		END;
	END IF;
 END;
$$

USE `hollyhotel`$$
DROP TRIGGER IF EXISTS `BUILDING_WING_BEFORE_UPDATE` $$
USE `hollyhotel`$$
CREATE TRIGGER `BUILDING_WING_BEFORE_UPDATE` BEFORE UPDATE ON `BUILDING_WING`
  FOR EACH ROW
  BEGIN
	DECLARE msg varchar(255);

    IF NEW.BuildingID not in (select TypeNameID from TYPE_NAME where UsageID = 'BuildingID') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.BuildingID;
		SET msg = concat(msg, ' is not a valid Building');
		SIGNAL sqlstate '45000' SET message_text = msg;
	END;
    ELSEIF NEW.WingID not in (select TypeNameID from TYPE_NAME where UsageID = 'WingID') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.WingID;
		SET msg = concat(msg, ' is not a valid Proximity Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
    END;
 END IF;
 END;
$$

USE `hollyhotel`$$
DROP TRIGGER IF EXISTS `RESERVATION_BEFORE_INSERT` $$
USE `hollyhotel`$$
CREATE TRIGGER `hollyhotel`.`RESERVATION_BEFORE_INSERT` BEFORE INSERT ON `RESERVATION` FOR EACH ROW
  BEGIN
	DECLARE msg varchar(255);

    IF NEW.RoomType not in (select TypeNameID from TYPE_NAME where UsageID = 'RoomType') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.RoomType;
		SET msg = concat(msg, ' is not a valid Room Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
	END;
    END IF;
 END;
 $$


USE `hollyhotel`$$
DROP TRIGGER IF EXISTS `RESERVATION_BEFORE_UPDATE` $$
USE `hollyhotel`$$
CREATE TRIGGER `hollyhotel`.`RESERVATION_BEFORE_UPDATE` BEFORE UPDATE ON `RESERVATION` FOR EACH ROW
  BEGIN
	DECLARE msg varchar(255);

    IF NEW.RoomType not in (select TypeNameID from TYPE_NAME where UsageID = 'RoomType') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.RoomType;
		SET msg = concat(msg, ' is not a valid Room Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
	END;
    END IF;
 END; $$


USE `hollyhotel`$$
DROP TRIGGER IF EXISTS `ROOM_BEDS_BEFORE_INSERT` $$
USE `hollyhotel`$$
CREATE TRIGGER `ROOM_BEDS_BEFORE_INSERT` BEFORE INSERT ON `ROOM_BEDS`
  FOR EACH ROW
  BEGIN
	DECLARE msg varchar(255);

    IF NEW.BedType not in (select TypeNameID from TYPE_NAME where UsageID = 'BedType') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.BedType;
		SET msg = concat(msg, ' is not a valid Bed Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
	END;

 END IF;
 END;
    $$


USE `hollyhotel`$$
DROP TRIGGER IF EXISTS `ROOM_BEDS_BEFORE_UPDATE` $$
USE `hollyhotel`$$
CREATE TRIGGER `ROOM_BEDS_BEFORE_UPDATE` BEFORE UPDATE ON `ROOM_BEDS`
  FOR EACH ROW
  BEGIN
	DECLARE msg varchar(255);

    IF NEW.BedType not in (select TypeNameID from TYPE_NAME where UsageID = 'BedType') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.BedType;
		SET msg = concat(msg, ' is not a valid Bed Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
	END;

 END IF;
 END; $$


USE `hollyhotel`$$
DROP TRIGGER IF EXISTS `ROOM_DETAIL_BEFORE_INSERT` $$
USE `hollyhotel`$$
CREATE TRIGGER `hollyhotel`.`ROOM_DETAIL_BEFORE_INSERT` BEFORE INSERT ON `ROOM_DETAIL` FOR EACH ROW
  BEGIN
	DECLARE msg varchar(255);

    IF NEW.RoomType not in (select TypeNameID from TYPE_NAME where UsageID = 'RoomType') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.RoomType;
		SET msg = concat(msg, ' is not a valid Room Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
	END;
    END IF;
 END; $$


USE `hollyhotel`$$
DROP TRIGGER IF EXISTS `ROOM_DETAIL_BEFORE_UPDATE` $$
USE `hollyhotel`$$
CREATE TRIGGER `hollyhotel`.`ROOM_DETAIL_BEFORE_UPDATE` BEFORE UPDATE ON `ROOM_DETAIL` FOR EACH ROW
  BEGIN
	DECLARE msg varchar(255);

    IF NEW.RoomType not in (select TypeNameID from TYPE_NAME where UsageID = 'RoomType') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.RoomType;
		SET msg = concat(msg, ' is not a valid Room Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
	END;
    END IF;
 END;
 $$


USE `hollyhotel`$$
DROP TRIGGER IF EXISTS `RES_FEATURES_BEFORE_INSERT` $$
USE `hollyhotel`$$
CREATE TRIGGER `hollyhotel`.`RES_FEATURES_BEFORE_INSERT` BEFORE INSERT ON `RES_FEATURES` FOR EACH ROW
  BEGIN
	DECLARE msg varchar(255);

    IF NEW.BedFeatureID not in (select TypeNameID from TYPE_NAME where UsageID = 'BedType' or UsageID = 'FeatureID') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.BedFeatureID;
		SET msg = concat(msg, ' is not a valid Bed/Feature Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
	END;
   ELSEIF NEW.ProximityID not in (select TypeNameID from TYPE_NAME where UsageID = 'ProximityID' UNION SELECT NULL AS TypeNameID UNION SELECT 0 AS TypeNameID ) then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.ProximityID;
		SET msg = concat(msg, ' is not a valid Proximity Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
    END;
    END IF;
 END; $$


USE `hollyhotel`$$
DROP TRIGGER IF EXISTS `RES_FEATURES_BEFORE_UPDATE` $$
USE `hollyhotel`$$

CREATE TRIGGER `hollyhotel`.`RES_FEATURES_BEFORE_UPDATE` BEFORE UPDATE ON `RES_FEATURES` FOR EACH ROW
  BEGIN
	DECLARE msg varchar(255);

    IF NEW.BedFeatureID not in (select TypeNameID from TYPE_NAME where UsageID = 'BedType' or UsageID = 'FeatureID') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.BedFeatureID;
		SET msg = concat(msg, ' is not a valid Bed/Feature Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
	END;
   ELSEIF NEW.ProximityID not in (select TypeNameID from TYPE_NAME where UsageID = 'ProximityID' UNION SELECT NULL AS TypeNameID UNION SELECT 0 AS TypeNameID) then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.ProximityID;
		SET msg = concat(msg, ' is not a valid Proximity Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
    END;
    END IF;
 END; $$


USE `hollyhotel`$$
DROP TRIGGER IF EXISTS `STAY_CHARGES_BEFORE_INSERT` $$
USE `hollyhotel`$$
CREATE TRIGGER `hollyhotel`.`STAY_CHARGES_BEFORE_INSERT` BEFORE INSERT ON `STAY_CHARGES` FOR EACH ROW
  BEGIN
	DECLARE msg varchar(255);

    IF NEW.ChargeType not in (select TypeNameID from TYPE_NAME where UsageID = 'ChargeType') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.ChargeType;
		SET msg = concat(msg, ' is not a valid Charge Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
	END;
    END IF;
 END; $$


USE `hollyhotel`$$
DROP TRIGGER IF EXISTS `STAY_CHARGES_BEFORE_UPDATE` $$
USE `hollyhotel`$$
CREATE TRIGGER `hollyhotel`.`STAY_CHARGES_BEFORE_UPDATE` BEFORE UPDATE ON `STAY_CHARGES` FOR EACH ROW
  BEGIN
	DECLARE msg varchar(255);

    IF NEW.ChargeType not in (select TypeNameID from TYPE_NAME where UsageID = 'ChargeType') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.ChargeType;
		SET msg = concat(msg, ' is not a valid Charge Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
	END;
    END IF;
 END; $$


USE `hollyhotel`$$
DROP TRIGGER IF EXISTS `MAINTENANCE_TICKET_BEFORE_INSERT` $$
USE `hollyhotel`$$
CREATE TRIGGER `hollyhotel`.`MAINTENANCE_TICKET_BEFORE_INSERT` BEFORE INSERT ON `MAINTENANCE_TICKET` FOR EACH ROW
  BEGIN
	DECLARE msg varchar(255);

    IF NEW.MaintenanceType not in (select TypeNameID from TYPE_NAME where UsageID = 'MaintenanceType') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.MaintenanceType;
		SET msg = concat(msg, ' is not a valid Maintenance Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
	END;
    ELSEIF IFNULL(NEW.EndDate,NEW.AnticipatedEndDate)<NEW.StartDate or NEW.AnticipatedEndDate<NEW.StartDate then
    BEGIN
		SET msg = concat('End date(s) must be greater than the Start Date/time of the maintenance');
		SIGNAL sqlstate '45000' SET message_text = msg;
    END;
 END IF;
 END; $$


USE `hollyhotel`$$
DROP TRIGGER IF EXISTS `MAINTENANCE_TICKET_BEFORE_UPDATE` $$
USE `hollyhotel`$$
CREATE TRIGGER `hollyhotel`.`MAINTENANCE_TICKET_BEFORE_UPDATE` BEFORE UPDATE ON `MAINTENANCE_TICKET` FOR EACH ROW
  BEGIN
	DECLARE msg varchar(255);

    IF NEW.MaintenanceType not in (select TypeNameID from TYPE_NAME where UsageID = 'MaintenanceType') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.MaintenanceType;
		SET msg = concat(msg, ' is not a valid Maintenance Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
	END;
    ELSEIF IFNULL(NEW.EndDate,NEW.AnticipatedEndDate)<NEW.StartDate or NEW.AnticipatedEndDate<NEW.StartDate then
    BEGIN
		SET msg = concat('End date(s) must be greater than the Start Date/time of the maintenance');
		SIGNAL sqlstate '45000' SET message_text = msg;
    END;
 END IF;
 END; $$


USE `hollyhotel`$$
DROP TRIGGER IF EXISTS `BUILDWING_FEATURES_BEFORE_INSERT` $$
USE `hollyhotel`$$
CREATE TRIGGER `BUILDWING_FEATURES_BEFORE_INSERT` BEFORE INSERT ON `BUILDING_WING_FEATURES`
  FOR EACH ROW
  BEGIN
	DECLARE msg varchar(255);

    IF NEW.FeatureID not in (select TypeNameID from TYPE_NAME where UsageID = 'FeatureID') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.FeatureID;
		SET msg = concat(msg, ' is not a valid Wing Feature');
		SIGNAL sqlstate '45000' SET message_text = msg;
	END;
    ELSEIF NEW.ProximityID not in (select TypeNameID from TYPE_NAME where UsageID = 'ProximityID') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.ProximityID;
		SET msg = concat(msg, ' is not a valid Proximity Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
    END; #elseif
 END IF;
 END;

    $$


USE `hollyhotel`$$
DROP TRIGGER IF EXISTS `BUILDWING_FEATURES_BEFORE_UPDATE` $$
USE `hollyhotel`$$
CREATE TRIGGER `BUILDWING_FEATURES_BEFORE_UPDATE` BEFORE UPDATE ON `BUILDING_WING_FEATURES`
  FOR EACH ROW
  BEGIN
	DECLARE msg varchar(255);

    IF NEW.FeatureID not in (select TypeNameID from TYPE_NAME where UsageID = 'FeatureID') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.FeatureID;
		SET msg = concat(msg, ' is not a valid Wing Feature');
		SIGNAL sqlstate '45000' SET message_text = msg;
	END;
    ELSEIF NEW.ProximityID not in (select TypeNameID from TYPE_NAME where UsageID = 'ProximityID') then
    BEGIN
		SELECT IFNULL(`Name`,'')  INTO msg from Type_Name where TypeNameID=NEW.ProximityID;
		SET msg = concat(msg, ' is not a valid Proximity Type');
		SIGNAL sqlstate '45000' SET message_text = msg;
    END;
 END IF;
 END; $$


DELIMITER ;



